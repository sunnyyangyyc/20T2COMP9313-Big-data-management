from pyspark.ml import Pipeline
from pyspark.ml.feature import CountVectorizer, StringIndexer, Tokenizer
from pyspark.sql.functions import udf
from pyspark.sql.types import DoubleType
from pyspark.ml.feature import OneHotEncoderEstimator, VectorAssembler


def base_features_gen_pipeline(input_descript_col="descript", input_category_col="category", output_feature_col="features", output_label_col="label"):

    # 'Descript' divides the content into separate words by the Tokenizer function
    Tokenizer_input = Tokenizer( inputCol = input_descript_col, outputCol = "new_word" )

    # Features are generated by CountVectorizer function
    Count_vectors = CountVectorizer( inputCol="new_word", outputCol=output_feature_col )

    # Through StringIndexer to add label
    Label_indexer = StringIndexer(inputCol=input_category_col, outputCol=output_label_col)

    pipeline = Pipeline(stages=[Tokenizer_input, Count_vectors, Label_indexer])
    return pipeline

def gen_meta_features(training_df, nb_0, nb_1, nb_2, svm_0, svm_1, svm_2):
    i = 0
    while i < 5:
        condition = training_df['group'] == i
        train_data = training_df.filter( ~condition )
        test_data = training_df.filter(condition)

        new_pipeline = Pipeline( stages = [nb_0, nb_1, nb_2, svm_0, svm_1, svm_2])
        if i == 0:
            DF = new_pipeline.fit(train_data).transform(test_data)
        else:
            DF = DF.union(new_pipeline.fit(train_data).transform(test_data))
        i += 1

    DF = DF.withColumn("joint_pred_0", DF["nb_pred_0"] * 2 + DF["svm_pred_0"] * 1)
    DF = DF.withColumn("joint_pred_1", DF["nb_pred_1"] * 2 + DF["svm_pred_1"] * 1)
    DF = DF.withColumn("joint_pred_2", DF["nb_pred_2"] * 2 + DF["svm_pred_2"] * 1)

    return DF


def test_prediction(test_df, base_features_pipeline_model, gen_base_pred_pipeline_model, gen_meta_feature_pipeline_model, meta_classifier):
    DataFrame_1 = base_features_pipeline_model.transform(test_df)
    DataFrame_2 = gen_base_pred_pipeline_model.transform(DataFrame_1)
    final_result = DataFrame_2.withColumn("joint_pred_0", DataFrame_2["nb_pred_0"] * 2 + DataFrame_2["svm_pred_0"] * 1)\
                        .withColumn("joint_pred_1", DataFrame_2["nb_pred_1"] * 2 + DataFrame_2["svm_pred_1"] * 1)\
                        .withColumn("joint_pred_2", DataFrame_2["nb_pred_2"] * 2 + DataFrame_2["svm_pred_2"] * 1)

    df_features = gen_meta_feature_pipeline_model.transform(final_result)
    prediction = meta_classifier.transform(df_features).select("id", "label", "final_prediction")
    return prediction
